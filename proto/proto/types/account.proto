syntax = "proto3";
package account;

import "types/primitives.proto";

// ACCOUNT
// ================================================================================================

// Uniquely identifies a specific account.
//
// A Miden account ID is a 120-bit value derived from the commitments to account code and storage,
// and a random user-provided seed.
message AccountId {
    // 15 bytes (120 bits) encoded using [winter_utils::Serializable] implementation for
    // [miden_objects::account::account_id::AccountId].
    bytes id = 1;
}

// The state of an account at a specific block height.
message AccountSummary {
    // The account ID.
    AccountId account_id = 1;

    // The current account commitment or zero if the account does not exist.
    primitives.Digest account_commitment = 2;

    // Block number at which the summary was made.
    uint32 block_num = 3;
}

// An account info.
message AccountInfo {
    // Account summary.
    AccountSummary summary = 1;

    // Account details encoded using [winter_utils::Serializable] implementation for
    // [miden_objects::account::Account].
    optional bytes details = 2;
}

// An account header.
message AccountHeader {
    // Vault root hash.
    primitives.Digest vault_root = 1;

    // Storage root hash.
    primitives.Digest storage_commitment = 2;

    // Code root hash.
    primitives.Digest code_commitment = 3;

    // Account nonce.
    uint64 nonce = 4;
}

// NOTES
// ================================================================================================

// Represents a note's metadata.
message NoteMetadata {
    // The account which sent the note.
    AccountId sender = 1;

    // The type of the note (0b01 = public, 0b10 = private, 0b11 = encrypted).
    uint32 note_type = 2;

    // A value which can be used by the recipient(s) to identify notes intended for them.
    //
    // See `miden_objects::note::note_tag` for more info.
    fixed32 tag = 3;

    // Specifies when a note is ready to be consumed.
    //
    // See `miden_objects::note::execution_hint` for more info.
    fixed64 execution_hint = 4;

    // An arbitrary user-defined value.
    fixed64 aux = 5;
}

// Represents a committed note.
//
// A committed note is a note that has been included in a block.
message CommittedNote {
    // Either private, public, or network note.
    Note note = 1;

    // The data needed to prove that the note is present in the chain.
    NoteInclusionInBlockProof inclusion_proof = 2;
}

// Represents a note.
//
// The note is composed of the note metadata and its serialized details.
message Note {
    // The note's metadata.
    NoteMetadata metadata = 1;

    // Serialized note details (empty for private notes).
    optional bytes details = 2;
}

// Represents a network note.
//
// The note is composed of the note metadata and its serialized details.
message NetworkNote {
    // The note's metadata.
    NoteMetadata metadata = 1;

    // Serialized note details (i.e., assets and recipient).
    bytes details = 2;
}

// Represents a proof of note's inclusion in a block.
//
// Does not include proof of the block's inclusion in the chain.
message NoteInclusionInBlockProof {
    // A unique identifier of the note which is a 32-byte commitment to the underlying note data.
    primitives.Digest note_id = 1;

    // The block number in which the note was created.
    fixed32 block_num = 2;

    // The index of the note in the block.
    uint32 note_index_in_block = 3;

    // The note's inclusion proof in the block.
    primitives.MerklePath merkle_path = 4;
}

// Represents proof of a note inclusion in the block.
message NoteSyncRecord {
    // The index of the note.
    uint32 note_index = 1;

    // A unique identifier of the note which is a 32-byte commitment to the underlying note data.
    primitives.Digest note_id = 2;

    // The note's metadata.
    NoteMetadata metadata = 3;

    // The note's inclusion proof in the block.
    primitives.MerklePath merkle_path = 4;
}
