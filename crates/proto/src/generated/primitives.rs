// This file is @generated by prost-build.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct Asset {
    /// Asset represented as a word.
    #[prost(message, optional, tag = "1")]
    pub asset: ::core::option::Option<Digest>,
}
/// Represents a single SMT leaf entry.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct SmtLeafEntry {
    /// The key of the entry.
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<Digest>,
    /// The value of the entry.
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Digest>,
}
/// Represents multiple leaf entries in an SMT.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmtLeafEntryList {
    /// The entries list.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<SmtLeafEntry>,
}
/// A leaf in an SMT, sitting at depth 64. A leaf can contain 0, 1 or multiple leaf entries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmtLeaf {
    #[prost(oneof = "smt_leaf::Leaf", tags = "1, 2, 3")]
    pub leaf: ::core::option::Option<smt_leaf::Leaf>,
}
/// Nested message and enum types in `SmtLeaf`.
pub mod smt_leaf {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Leaf {
        /// An empty leaf index.
        #[prost(uint64, tag = "1")]
        EmptyLeafIndex(u64),
        /// A single leaf entry.
        #[prost(message, tag = "2")]
        Single(super::SmtLeafEntry),
        /// Multiple leaf entries.
        #[prost(message, tag = "3")]
        Multiple(super::SmtLeafEntryList),
    }
}
/// The opening of a leaf in an SMT.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmtOpening {
    /// The Merkle path to the leaf.
    #[prost(message, optional, tag = "1")]
    pub path: ::core::option::Option<SparseMerklePath>,
    /// The leaf itself.
    #[prost(message, optional, tag = "2")]
    pub leaf: ::core::option::Option<SmtLeaf>,
}
/// A different representation of a Merkle path designed for memory efficiency.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SparseMerklePath {
    /// A bitmask representing empty nodes.
    ///
    /// The set bit corresponds to the depth of an empty node. The least significant bit (bit 0)
    /// describes depth 1 node (root's children). The `bit index + 1` is equal to node's depth.
    #[prost(fixed64, tag = "1")]
    pub empty_nodes_mask: u64,
    /// The non-empty nodes, stored in depth-order, but not contiguous across depth.
    #[prost(message, repeated, tag = "2")]
    pub siblings: ::prost::alloc::vec::Vec<Digest>,
}
/// Represents an MMR delta.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MmrDelta {
    /// The number of leaf nodes in the MMR.
    #[prost(uint64, tag = "1")]
    pub forest: u64,
    /// New and changed MMR peaks.
    #[prost(message, repeated, tag = "2")]
    pub data: ::prost::alloc::vec::Vec<Digest>,
}
/// Represents a Merkle path.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerklePath {
    /// List of sibling node hashes, in order from the root to the leaf.
    #[prost(message, repeated, tag = "1")]
    pub siblings: ::prost::alloc::vec::Vec<Digest>,
}
/// A hash digest, the result of a hash function.
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
#[prost(skip_debug)]
pub struct Digest {
    #[prost(fixed64, tag = "1")]
    pub d0: u64,
    #[prost(fixed64, tag = "2")]
    pub d1: u64,
    #[prost(fixed64, tag = "3")]
    pub d2: u64,
    #[prost(fixed64, tag = "4")]
    pub d3: u64,
}
/// Represents a partial Sparse Merkle Tree containing only a subset of leaves and their paths.
/// This allows verifying and updating tracked keys without requiring the full tree.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartialSmt {
    /// The root hash of the SMT
    #[prost(message, optional, tag = "1")]
    pub root: ::core::option::Option<Digest>,
    /// All tracked leaves in the partial SMT, keyed by their leaf index
    #[prost(message, repeated, tag = "2")]
    pub leaves: ::prost::alloc::vec::Vec<SmtLeafWithIndex>,
    /// Inner nodes stored in deterministic order (by scalar index) for reconstruction
    #[prost(message, repeated, tag = "3")]
    pub inner_nodes: ::prost::alloc::vec::Vec<InnerNode>,
}
/// Represents a leaf with its index for partial SMT serialization
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmtLeafWithIndex {
    /// The leaf index (0 to 2^64 - 1 for leaves at depth 64)
    #[prost(uint64, tag = "1")]
    pub leaf_index: u64,
    /// The leaf data
    #[prost(message, optional, tag = "2")]
    pub leaf: ::core::option::Option<SmtLeaf>,
}
#[derive(Clone, Copy, PartialEq, Eq, Hash, ::prost::Message)]
pub struct InnerNode {
    #[prost(message, optional, tag = "1")]
    pub left: ::core::option::Option<Digest>,
    #[prost(message, optional, tag = "2")]
    pub right: ::core::option::Option<Digest>,
}
