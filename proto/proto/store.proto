// Specification of the store RPC.
//
// This provided access to the rollup data to the other nodes.
syntax = "proto3";
package store;

import "types/account.proto";
import "types/blockchain.proto";
import "types/transaction.proto";
import "types/primitives.proto";
import "types/note.proto";
import "google/protobuf/empty.proto";

// RPC API
// ================================================================================================

// Store API for the RPC component
service Rpc {
    // Returns the status info.
    rpc Status(google.protobuf.Empty) returns (StoreStatus) {}

    // Returns a nullifier proof for each of the requested nullifiers.
    rpc CheckNullifiers(Nullifiers) returns (CheckNullifiersResponse) {}

    // Returns a list of nullifiers that match the specified prefixes and are recorded in the node.
    //
    // Note that only 16-bit prefixes are supported at this time.
    rpc CheckNullifiersByPrefix(CheckNullifiersByPrefixRequest) returns (CheckNullifiersByPrefixResponse) {}

    // Returns the latest state of an account with the specified ID.
    rpc GetAccountDetails(account.AccountId) returns (account.AccountDetails) {}

    // Returns the latest state proofs of the specified accounts.
    rpc GetAccountProofs(GetAccountProofsRequest) returns (AccountProofs) {}

    // Returns delta of the account states in the range from `from_block_num` (exclusive) to
    // `to_block_num` (inclusive).
    rpc GetAccountStateDelta(GetAccountStateDeltaRequest) returns (AccountStateDelta) {}

    // Returns raw block data for the specified block number.
    rpc GetBlockByNumber(blockchain.BlockNumber) returns (blockchain.MaybeBlock) {}

    // Retrieves block header by given block number. Optionally, it also returns the MMR path
    // and current chain length to authenticate the block's inclusion.
    rpc GetBlockHeaderByNumber(BlockHeaderByNumberRequest) returns (BlockHeaderByNumberResponse) {}

    // Returns a list of committed notes matching the provided note IDs.
    rpc GetNotesById(note.NoteIds) returns (note.CommittedNotes) {}

    // Returns info which can be used by the client to sync up to the tip of chain for the notes they are interested in.
    //
    // Client specifies the `note_tags` they are interested in, and the block height from which to search for new for
    // matching notes for. The request will then return the next block containing any note matching the provided tags.
    //
    // The response includes each note's metadata and inclusion proof.
    //
    // A basic note sync can be implemented by repeatedly requesting the previous response's block until reaching the
    // tip of the chain. 
    rpc SyncNotes(SyncNotesRequest) returns (SyncNotesResponse) {}

    // Returns info which can be used by the client to sync up to the latest state of the chain
    // for the objects (accounts, notes, nullifiers) the client is interested in.
    //
    // This request returns the next block containing requested data. It also returns `chain_tip`
    // which is the latest block number in the chain. Client is expected to repeat these requests
    // in a loop until `response.block_header.block_num == response.chain_tip`, at which point
    // the client is fully synchronized with the chain.
    //
    // Each request also returns info about new notes, nullifiers etc. created. It also returns
    // Chain MMR delta that can be used to update the state of Chain MMR. This includes both chain
    // MMR peaks and chain MMR nodes.
    //
    // For preserving some degree of privacy, note tags and nullifiers filters contain only high
    // part of hashes. Thus, returned data contains excessive notes and nullifiers, client can make
    // additional filtering of that data on its side.
    rpc SyncState(SyncStateRequest) returns (SyncStateResponse) {}
}

// BLOCK PRODUCER API
// ================================================================================================

// Store API for the BlockProducer component
service BlockProducer {
    // Applies changes of a new block to the DB and in-memory data structures.
    rpc ApplyBlock(blockchain.Block) returns (google.protobuf.Empty) {}

    // Retrieves block header by given block number. Optionally, it also returns the MMR path
    // and current chain length to authenticate the block's inclusion.
    rpc GetBlockHeaderByNumber(BlockHeaderByNumberRequest) returns (BlockHeaderByNumberResponse) {}

    // Returns data required to prove the next block.
    rpc GetBlockInputs(GetBlockInputsRequest) returns (BlockInputs) {}

    // Returns the inputs for a transaction batch.
    rpc GetBatchInputs(GetBatchInputsRequest) returns (BatchInputs) {}

    // Returns data required to validate a new transaction.
    rpc GetTransactionInputs(GetTransactionInputsRequest) returns (TransactionInputs) {}
}

// NTX BUILDER API
// ================================================================================================

// Store API for the network transaction builder component
service NtxBuilder {
    // Retrieves block header by given block number. Optionally, it also returns the MMR path
    // and current chain length to authenticate the block's inclusion.
    rpc GetBlockHeaderByNumber(BlockHeaderByNumberRequest) returns (BlockHeaderByNumberResponse) {}

    // Returns the list of unconsumed network notes and the next page number to query.
    rpc GetUnconsumedNetworkNotes(GetUnconsumedNetworkNotesRequest) returns (UnconsumedNetworkNotes) {}

    // Returns the block header at the chain tip, as well as the MMR peaks corresponding to this 
    // header for executing network transactions. If the block number is not provided, the latest
    // header and peaks will be retrieved.
    rpc GetCurrentBlockchainData(blockchain.MaybeBlockNumber) returns (CurrentBlockchainData) {}

    // Returns the latest state of a network account with the specified account prefix.
    rpc GetNetworkAccountDetailsByPrefix(AccountIdPrefix) returns (MaybeAccountDetails) {}
}

// GET UNCONSUMED NETWORK NOTES
// ================================================================================================

// Returns a list of unconsumed network notes using pagination.
message GetUnconsumedNetworkNotesRequest {
    // An opaque token used to paginate through the notes.
    //
    // This should be null on the first call, and set to the response
    // token until the response token is null, at which point all data
    // has been fetched.
    optional uint64 page_token = 1;

    // Number of notes to retrieve per page.
    uint64 page_size = 2;
}

// Represents the result of getting the unconsumed network notes.
message UnconsumedNetworkNotes {
    // An opaque pagination token.
    //
    // Use this in your next request to get the next
    // set of data.
    //
    // Will be null once there is no more data remaining.
    optional uint64 next_token = 1;

    // The list of unconsumed network notes.
    repeated note.NetworkNote notes = 2;
}

// GET NETWORK ACCOUNT DETAILS BY PREFIX
// ================================================================================================

// Account ID prefix.
message AccountIdPrefix {
    // Account ID prefix.
    fixed32 account_id_prefix = 1;
}

// Represents the result of getting network account details by prefix.
message MaybeAccountDetails {
    // Account details.
    optional account.AccountDetails details = 1;
}

// GET BLOCK INPUTS
// ================================================================================================

// Returns data required to prove the next block.
message GetBlockInputsRequest {
    // IDs of all accounts updated in the proposed block for which to retrieve account witnesses.
    repeated account.AccountId account_ids = 1;

    // Nullifiers of all notes consumed by the block for which to retrieve witnesses.
    //
    // Due to note erasure it will generally not be possible to know the exact set of nullifiers
    // a block will create, unless we pre-execute note erasure. So in practice, this set of
    // nullifiers will be the set of nullifiers of all proven batches in the block, which is a
    // superset of the nullifiers the block may create.
    //
    // However, if it is known that a certain note will be erased, it would not be necessary to
    // provide a nullifier witness for it.
    repeated primitives.Digest nullifiers = 2;

    // Array of note IDs for which to retrieve note inclusion proofs, **if they exist in the store**.
    repeated primitives.Digest unauthenticated_notes = 3;

    // Array of block numbers referenced by all batches in the block.
    repeated fixed32 reference_blocks = 4;
}

// Represents the result of getting block inputs.
message BlockInputs {
    // The latest block header.
    blockchain.BlockHeader latest_block_header = 1;

    // Proof of each requested unauthenticated note's inclusion in a block, **if it existed in
    // the store**.
    repeated note.NoteInclusionInBlockProof unauthenticated_note_proofs = 2;

    // The serialized chain MMR which includes proofs for all blocks referenced by the
    // above note inclusion proofs as well as proofs for inclusion of the requested blocks
    // referenced by the batches in the block.
    bytes partial_block_chain = 3;

    // The state commitments of the requested accounts and their authentication paths.
    repeated account.AccountWitness account_witnesses = 4;

    // The requested nullifiers and their authentication paths.
    repeated NullifierWitness nullifier_witnesses = 5;
}

// GET BATCH INPUTS
// ================================================================================================

// Returns the inputs for a transaction batch.
message GetBatchInputsRequest {
  // List of unauthenticated notes to be queried from the database.
  repeated primitives.Digest note_ids = 1;
  // Set of block numbers referenced by transactions.
  repeated fixed32 reference_blocks = 2;
}

// Represents the result of getting batch inputs.
message BatchInputs {
    // The block header that the transaction batch should reference.
    blockchain.BlockHeader batch_reference_block_header = 1;
  
    // Proof of each _found_ unauthenticated note's inclusion in a block.
    repeated note.NoteInclusionInBlockProof note_proofs = 2;
  
    // The serialized chain MMR which includes proofs for all blocks referenced by the
    // above note inclusion proofs as well as proofs for inclusion of the blocks referenced
    // by the transactions in the batch.
    bytes partial_block_chain = 3;
}

// GET TRANSACTION INPUTS
// ================================================================================================

// Returns data required to validate a new transaction.
message GetTransactionInputsRequest {
    // ID of the account against which a transaction is executed.
    account.AccountId account_id = 1;
    // Set of nullifiers consumed by this transaction.
    repeated primitives.Digest nullifiers = 2;
    // Set of unauthenticated notes to check for existence on-chain.
    //
    // These are notes which were not on-chain at the state the transaction was proven,
    // but could by now be present.
    repeated primitives.Digest unauthenticated_notes = 3;
}

// Represents the result of getting transaction inputs.
message TransactionInputs {
    // An account returned as a response to the `GetTransactionInputs`.
    message AccountTransactionInputRecord {
        // The account ID.
        account.AccountId account_id = 1;

        // The latest account commitment, zero commitment if the account doesn't exist.
        primitives.Digest account_commitment = 2;
    }

    // A nullifier returned as a response to the `GetTransactionInputs`.
    message NullifierTransactionInputRecord {
        // The nullifier ID.
        primitives.Digest nullifier = 1;

        // The block at which the nullifier has been consumed, zero if not consumed.
        fixed32 block_num = 2;
    }

    // Account state proof.
    AccountTransactionInputRecord account_state = 1;

    // List of nullifiers that have been consumed.
    repeated NullifierTransactionInputRecord nullifiers = 2;

    // List of unauthenticated notes that were not found in the database.
    repeated primitives.Digest found_unauthenticated_notes = 3;

    // The node's current block height.
    fixed32 block_height = 4;
}

// GET CURRENT BLOCKCHAIN DATA
// ================================================================================================

// Current blockchain data based on the requested block number.
message CurrentBlockchainData {
    // Commitments that represent the current state according to the MMR.
    repeated primitives.Digest current_peaks = 1;
    // Current block header.
    optional blockchain.BlockHeader current_block_header = 2;
}

// A nullifier returned as a response to the `GetBlockInputs`.
message NullifierWitness {
    // The nullifier.
    primitives.Digest nullifier = 1;

    // The SMT proof to verify the nullifier's inclusion in the nullifier tree.
    primitives.SmtOpening opening = 2;
}

// GET ACCOUNT PROOFS
// ================================================================================================

// Returns the latest state proofs of the specified accounts.
message GetAccountProofsRequest {
    // Represents per-account requests where each account ID has its own list of
    // (storage_slot_index, map_keys) pairs.
    message AccountRequest {
        // Represents a storage slot index and the associated map keys.
        message StorageRequest {
            // Storage slot index ([0..255])
            uint32 storage_slot_index = 1;

            // A list of map keys (Digests) associated with this storage slot.
            repeated primitives.Digest map_keys = 2;
        }

        // The account ID for this request.
        account.AccountId account_id = 1;

        // List of storage requests for this account.
        repeated StorageRequest storage_requests = 2;
    }

    // A list of account requests, including map keys + values.
    repeated AccountRequest account_requests = 1;

    // Optional flag to include account headers and account code in the response. If false, storage
    // requests are also ignored. False by default.
    optional bool include_headers = 2;

    // Account code commitments corresponding to the last-known `AccountCode` for requested
    // accounts. Responses will include only the ones that are not known to the caller.
    // These are not associated with a specific account but rather, they will be matched against
    // all requested accounts.
    repeated primitives.Digest code_commitments = 3;
}

// Represents the result of getting account proofs.
message AccountProofs {
    // A single account proof returned as a response to `GetAccountProofs`.
    message AccountProof {
        // State header for public accounts.
        message AccountStateHeader {
            // Represents a single storage slot with the requested keys and their respective values.
            message StorageSlotMapProof {
                // The storage slot index ([0..255]).
                uint32 storage_slot = 1;

                // Merkle proof of the map value
                bytes smt_proof = 2;
            }

            // Account header.
            account.AccountHeader header = 1;

            // Values of all account storage slots (max 255).
            bytes storage_header = 2;

            // Account code, returned only when none of the request's code commitments match
            // the current one.
            optional bytes account_code = 3;

            // Storage slots information for this account
            repeated StorageSlotMapProof storage_maps = 4;
        }

        // The account witness for the current state commitment of one account ID.
        account.AccountWitness witness = 1;

        // State header for public accounts. Filled only if `include_headers` flag is set to `true`.
        optional AccountStateHeader state_header = 2;
    }

    // Block number at which the state of the accounts is returned.
    fixed32 block_num = 1;

    // List of account state infos for the requested account keys.
    repeated AccountProof account_proofs = 2;
}

// STORE STATUS
// ================================================================================================

// Represents the status of the store.
message StoreStatus {
    // The store's running version.
    string version = 1;

    // The store's status.
    string status = 2;

    // Number of the latest block in the chain.
    fixed32 chain_tip = 3;
}

// GET ACCOUNT STATE DELTA
// ================================================================================================

// Returns delta of the account states in the range from `from_block_num` (exclusive) to
// `to_block_num` (inclusive).
message GetAccountStateDeltaRequest {
    // ID of the account for which the delta is requested.
    account.AccountId account_id = 1;
    // Block number from which the delta is requested (exclusive).
    fixed32 from_block_num = 2;
    // Block number up to which the delta is requested (inclusive).
    fixed32 to_block_num = 3;
}

// Represents the result of getting account state delta.
message AccountStateDelta {
    // The calculated account delta encoded using [winter_utils::Serializable] implementation
    // for [miden_objects::account::delta::AccountDelta].
    optional bytes delta = 1;
}

// CHECK NULLIFIERS BY PREFIX
// ================================================================================================

// Returns a list of nullifiers that match the specified prefixes and are recorded in the node.
message CheckNullifiersByPrefixRequest {
    // Number of bits used for nullifier prefix. Currently the only supported value is 16.
    uint32 prefix_len = 1;
    // List of nullifiers to check. Each nullifier is specified by its prefix with length equal
    // to `prefix_len`.
    repeated uint32 nullifiers = 2;
    // Block number from which the nullifiers are requested (inclusive).
    fixed32 block_num = 3;
}

// Represents the result of checking nullifiers by prefix.
message CheckNullifiersByPrefixResponse {
    // Represents a single nullifier update.
    message NullifierUpdate {
        // Nullifier ID.
        primitives.Digest nullifier = 1;

        // Block number.
        fixed32 block_num = 2;
    }
    // List of nullifiers matching the prefixes specified in the request.
    repeated NullifierUpdate nullifiers = 1;
}

// CHECK NULLIFIERS
// ================================================================================================

// List of nullifiers to return proofs for.
message Nullifiers {
    // List of nullifiers to return proofs for.
    repeated primitives.Digest nullifiers = 1;
}

// Represents the result of checking nullifiers.
message CheckNullifiersResponse {
    // Each requested nullifier has its corresponding nullifier proof at the same position.
    repeated primitives.SmtOpening proofs = 1;
}

// GET BLOCK HEADER BY NUMBER
// ================================================================================================

// Returns the block header corresponding to the requested block number, as well as the merkle
// path and current forest which validate the block's inclusion in the chain.
//
// The Merkle path is an MMR proof for the block's leaf, based on the current chain length.
message BlockHeaderByNumberRequest {
    // The target block height, defaults to latest if not provided.
    optional uint32 block_num = 1;
    // Whether or not to return authentication data for the block header.
    optional bool include_mmr_proof = 2;
}

// Represents the result of getting a block header by block number.
message BlockHeaderByNumberResponse {
    // The requested block header.
    blockchain.BlockHeader block_header = 1;

    // Merkle path to verify the block's inclusion in the MMR at the returned `chain_length`.
    optional primitives.MerklePath mmr_path = 2;

    // Current chain length.
    optional fixed32 chain_length = 3;
}


// SYNC STATE
// ================================================================================================

// State synchronization request.
//
// Specifies state updates the client is interested in. The server will return the first block which
// contains a note matching `note_tags` or the chain tip. And the corresponding updates to
// `account_ids` for that block range.
message SyncStateRequest {
    // Last block known by the client. The response will contain data starting from the next block,
    // until the first block which contains a note of matching the requested tag, or the chain tip
    // if there are no notes.
    fixed32 block_num = 1;

    // Accounts' commitment to include in the response.
    //
    // An account commitment will be included if-and-only-if it is the latest update. Meaning it is
    // possible there was an update to the account for the given range, but if it is not the latest,
    // it won't be included in the response.
    repeated account.AccountId account_ids = 2;

    // Specifies the tags which the client is interested in.
    repeated fixed32 note_tags = 3;
}

// Represents the result of syncing state request.
message SyncStateResponse {
    // Number of the latest block in the chain.
    fixed32 chain_tip = 1;

    // Block header of the block with the first note matching the specified criteria.
    blockchain.BlockHeader block_header = 2;

    // Data needed to update the partial MMR from `request.block_num + 1` to `response.block_header.block_num`.
    primitives.MmrDelta mmr_delta = 3;

    // List of account commitments updated after `request.block_num + 1` but not after `response.block_header.block_num`.
    repeated account.AccountSummary accounts = 5;

    // List of transactions executed against requested accounts between `request.block_num + 1` and
    // `response.block_header.block_num`.
    repeated transaction.TransactionSummary transactions = 6;

    // List of all notes together with the Merkle paths from `response.block_header.note_root`.
    repeated note.NoteSyncRecord notes = 7;
}

// SYNC NOTES
// ================================================================================================

// Note synchronization request.
//
// Specifies note tags that client is interested in. The server will return the first block which
// contains a note matching `note_tags` or the chain tip.
message SyncNotesRequest {
    // Last block known by the client. The response will contain data starting from the next block,
    // until the first block which contains a note of matching the requested tag.
    fixed32 block_num = 1;

    // Specifies the tags which the client is interested in.
    repeated fixed32 note_tags = 2;
}

// Represents the result of syncing notes request.
message SyncNotesResponse {
    // Number of the latest block in the chain.
    fixed32 chain_tip = 1;

    // Block header of the block with the first note matching the specified criteria.
    blockchain.BlockHeader block_header = 2;

    // Merkle path to verify the block's inclusion in the MMR at the returned `chain_tip`.
    //
    // An MMR proof can be constructed for the leaf of index `block_header.block_num` of
    // an MMR of forest `chain_tip` with this path.
    primitives.MerklePath mmr_path = 3;

    // List of all notes together with the Merkle paths from `response.block_header.note_root`.
    repeated note.NoteSyncRecord notes = 4;
}
