// This file is @generated by prost-build.
/// Representation of a partial sparse merkle tree.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PartialSmt {
    /// The sparse merkle tree root.
    #[prost(message, optional, tag = "1")]
    pub root: ::core::option::Option<Digest>,
    /// Set of leaves of the merkle tree.
    #[prost(message, repeated, tag = "2")]
    pub leaves: ::prost::alloc::vec::Vec<SmtLeaf>,
    /// Unique set of inner merkle tree digest, all belonging to at least one
    /// merkle path of a given leave. Note that we skip all inner nodes that do
    /// have two children, since we can recalculate them on-the-fly.
    #[prost(message, repeated, tag = "3")]
    pub nodes: ::prost::alloc::vec::Vec<InnerNode>,
}
/// Node index representation.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct NodeIndex {
    /// The depth of the index, starting from 0 as root.
    #[prost(uint32, tag = "1")]
    pub depth: u32,
    /// The index within a certain tree depth, left-most being zero.
    #[prost(uint64, tag = "2")]
    pub value: u64,
}
/// Inner node of a sparse merkle tree
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct InnerNode {
    /// The position of the inner node within the tree.
    #[prost(message, optional, tag = "1")]
    pub index: ::core::option::Option<NodeIndex>,
    /// The digest of the subtree down to the root.
    #[prost(message, optional, tag = "2")]
    pub digest: ::core::option::Option<Digest>,
}
/// Represents a single SMT leaf entry.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct SmtLeafEntry {
    /// The key of the entry.
    #[prost(message, optional, tag = "1")]
    pub key: ::core::option::Option<Digest>,
    /// The value of the entry.
    #[prost(message, optional, tag = "2")]
    pub value: ::core::option::Option<Digest>,
}
/// Represents multiple leaf entries in an SMT.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmtLeafEntryList {
    /// The entries list.
    #[prost(message, repeated, tag = "1")]
    pub entries: ::prost::alloc::vec::Vec<SmtLeafEntry>,
}
/// A leaf in an SMT, sitting at depth 64. A leaf can contain 0, 1 or multiple leaf entries.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmtLeaf {
    #[prost(oneof = "smt_leaf::Leaf", tags = "1, 2, 3")]
    pub leaf: ::core::option::Option<smt_leaf::Leaf>,
}
/// Nested message and enum types in `SmtLeaf`.
pub mod smt_leaf {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Leaf {
        /// An empty leaf index.
        #[prost(uint64, tag = "1")]
        EmptyLeafIndex(u64),
        /// A single leaf entry.
        #[prost(message, tag = "2")]
        Single(super::SmtLeafEntry),
        /// Multiple leaf entries.
        #[prost(message, tag = "3")]
        Multiple(super::SmtLeafEntryList),
    }
}
/// The opening of a leaf in an SMT.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SmtOpening {
    /// The Merkle path to the leaf.
    #[prost(message, optional, tag = "1")]
    pub path: ::core::option::Option<MerklePath>,
    /// The leaf itself.
    #[prost(message, optional, tag = "2")]
    pub leaf: ::core::option::Option<SmtLeaf>,
}
/// A different representation of a Merkle path designed for memory efficiency.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SparseMerklePath {
    /// A bitmask representing empty nodes.
    ///
    /// The set bit corresponds to the depth of an empty node. The least significant bit (bit 0)
    /// describes depth 1 node (root's children). The `bit index + 1` is equal to node's depth.
    #[prost(fixed64, tag = "1")]
    pub empty_nodes_mask: u64,
    /// The non-empty nodes, stored in depth-order, but not contiguous across depth.
    #[prost(message, repeated, tag = "2")]
    pub siblings: ::prost::alloc::vec::Vec<Digest>,
}
/// Represents an MMR delta.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MmrDelta {
    /// The number of leaf nodes in the MMR.
    #[prost(uint64, tag = "1")]
    pub forest: u64,
    /// New and changed MMR peaks.
    #[prost(message, repeated, tag = "2")]
    pub data: ::prost::alloc::vec::Vec<Digest>,
}
/// Represents a Merkle path.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MerklePath {
    /// List of sibling node hashes, in order from the root to the leaf.
    #[prost(message, repeated, tag = "1")]
    pub siblings: ::prost::alloc::vec::Vec<Digest>,
}
/// A hash digest, the result of a hash function.
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
#[prost(skip_debug)]
pub struct Digest {
    #[prost(fixed64, tag = "1")]
    pub d0: u64,
    #[prost(fixed64, tag = "2")]
    pub d1: u64,
    #[prost(fixed64, tag = "3")]
    pub d2: u64,
    #[prost(fixed64, tag = "4")]
    pub d3: u64,
}
